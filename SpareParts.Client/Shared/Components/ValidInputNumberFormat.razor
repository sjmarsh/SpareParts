@using System.Linq.Expressions
@using System.Diagnostics.CodeAnalysis
@using System.Globalization
@using System.Reflection

@typeparam TModel

<div class="form-group my-2">

    @if(DisplayName != null)
    {
        <label for="@Id">@DisplayName</label>
    }
    <input id="@Id" type="string" class="form-control @_validClass @CssClass" 
        value="@_displayValue" @onchange="@(e => _displayValue = GetNumericValue(e))" @oninvalid="HandleInvalid" />

    @if(ValueExpression != null)
    {
        <ValidationMessage For="ValueExpression" />    
    }
    
</div>

@code {

    [Parameter, EditorRequired] 
    public string? Id { get; set; }

    [Parameter]
    public string? DisplayName { get; set; }

    [Parameter]
    public string? StringFormat { get; set; }

    [Parameter]
    public string? CssClass { get; set; }

    [Parameter, EditorRequired]
    public TModel Model { get; set; } = default!;

    [Parameter, EditorRequired] 
    public Expression<Func<double>> ValueExpression { get; set; } = default!;

    // This will come from the EditForm that this component should be wrapped in when used
    [CascadingParameter]
    private EditContext CascadedEditContext { get; set; } = default!;

    private string _displayValue = "";
    private string _validClass = "";

    protected override void OnInitialized()
    {
        _displayValue = GetDisplayValue();
    }

    private string GetDisplayValue()
    {
        var value = GetValueFromExpression(ValueExpression);
        return value.ToString(StringFormat);
    }

    private string GetNumericValue(ChangeEventArgs e)
    {
        if(e != null && e.Value != null && double.TryParse(e.Value.ToString(), NumberStyles.Any, CultureInfo.CurrentCulture, out var numVal))
        {
            SetValueFromExpression<TModel, double>(Model, ValueExpression, numVal);
            HandleModelValidation();
            return numVal.ToString(StringFormat);
        }
        else
        {
            _validClass = "modified invalid";
            return string.Empty;

        }
    }

    private void HandleModelValidation()
    {
        if(CascadedEditContext != null && ValueExpression != null)
        {
            var fieldName = GetMemberNameFromExpression(ValueExpression);
            var field = CascadedEditContext.Field("Price"); 
            CascadedEditContext.NotifyFieldChanged(field);
            if (CascadedEditContext.GetValidationMessages(field).Any())
            {
                _validClass = "modified invalid";
            }
            else
            {
                _validClass = "modified valid";
            }
        }
    }

    private void HandleInvalid()
    {
        // fallback HTML validation
        _validClass = "modified invalid";
    }

    // TODO - Move the following to external utility class

    private double GetValueFromExpression(Expression<Func<double>> expression)
    {
        var compiled = expression.Compile();
        return compiled();
    }

    private string GetMemberNameFromExpression<TValue>(Expression<Func<TValue>> expression)
    {
        return GetMemberInfoFromExpression(expression).Name;
    }

    private void SetValueFromExpression<TM, TValue>(TModel model, Expression<Func<TValue>> expression, double value)
    {        
        var prop = GetMemberInfoFromExpression(expression) as PropertyInfo;
        prop?.SetValue(model, value, null);

    }

    private MemberInfo GetMemberInfoFromExpression<TValue>(Expression<Func<TValue>> expression)
    {
        MemberExpression forMember = expression.Body switch
        {
            MemberExpression memberExpression => memberExpression,
            UnaryExpression { Operand: MemberExpression unaryMemberExpression } => unaryMemberExpression,
            _ => throw new InvalidOperationException("Must be an expression terminating in a member")
        };

        return forMember.Member;
    }
}